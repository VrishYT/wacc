package wacc

import wacc.front.{Parser, SemanticChecker}
import wacc.front.error.{ErrorLogger, TypeException, WACCError, WACCErrorBuilder}
import wacc.back._

import java.io.{File, FileWriter, BufferedWriter}

class Compiler(private val file: File) {

    import wacc.ast._
    import parsley.{Success, Failure}
    import parsley.combinator.skipMany
    import parsley.character.whitespace
    import parsley.errors.{ErrorBuilder, Token}
    import parsley.errors.tokenextractors.{LexToken, TillNextWhitespace}
    import parsley.Parsley
    import parsley.io._
    import wacc.front.Lexing.{lexer, keywords}

    private var program: Option[Program] = None 
    private val symbolTable = new SymbolTable(new DataSection)

    def parse(): Boolean = {
        val pNode = Parser.program

        /*defined the errorbuilder to use the lexToken for the token extractor*/ 
        implicit val eb: ErrorBuilder[WACCError] = new WACCErrorBuilder with LexToken {
            /*define the tokens that we want lexToken to recognise, and format them to print the token accordingly*/
            private val idents = skipMany(whitespace) *> lexer.nonlexeme.names.identifier.map(x => s"identifier $x")
            private val ints = skipMany(whitespace) *> lexer.nonlexeme.numeric.integer.decimal32.map(x => s"integer $x")
            private val open_paren = skipMany(whitespace) *> lexer.nonlexeme.symbol.openParen.map(x => s"opening parenthesis")
            private val square_paren = skipMany(whitespace) *> lexer.nonlexeme.symbol.openSquare.map(x => s"square parenthesis")
            private val keyword_ = LexToken.constantSymbols((keywords.map(x => (skipMany(whitespace) *> lexer.nonlexeme.symbol(x), s"keyword $x")).toList): _*)

            def tokens: Seq[Parsley[String]] = idents +: ints +: square_paren +: open_paren +: keyword_ 

            /*LexToken requires a strategy for how to extract if the error originates inside the Lexer, in which we use TillNextWhitespace*/
            override def extractItem(cs: Iterable[Char], amountOfInputParserWanted: Int): Token = TillNextWhitespace.unexpectedToken(cs, amountOfInputParserWanted)
            
        } 

        val result = pNode.parseFromFile(file)
        result match {
            case util.Success(x) => x match {
                case Success(x) => {
                    program = Some(x)
                    true
                }
                case x: Failure[WACCError] => {
                    println(x.msg)
                    false           
                }
            }
            case x: util.Failure[_] => ErrorLogger.err("cannot read file", 1)
        }
    }
    
    def typecheck: Boolean = program match {
        case Some(x) => {
            val errors = SemanticChecker.typecheck(x, symbolTable)
            if (errors.isEmpty) return true

            TypeException.convertErrors(errors, file).foreach(println)
            return false
        }
        case None => ErrorLogger.err("typecheck called before parse", 1)

    }

    def compile: Unit = program match {
        case Some(x) => {

            // TODO: check if function needed or inline
            def writeToFile(out: String): Unit = {
                val writer = new BufferedWriter(new FileWriter(new File(file.getName.toString.replace(".wacc", ".s"))))
                writer.write(out)
                writer.close
            } 

            val gen = new CodeGenerator(symbolTable)
            val out = gen.toAssembly(x)
            writeToFile(out)
        }
        case None => ErrorLogger.err("generate called before parse/typecheck", 1)
    }

}

object Compiler {

    def apply(targetFile: String): Compiler = new Compiler(new File(targetFile))

    def getUsage: String = {
        val sep = System.getProperty("line.separator")
        val s = new StringBuilder("Usage: ./compile [options] <target.wacc>")
        s.append(sep)
        s.append("   options:")
        s.append(sep)
        s.append("       -p, --only-parse        Parse only. Check the input file for syntax errors and generate an AST.")
        s.append(sep)
        s.append("       -s, --only-typecheck    Semantic check. Parse the file for syntax and semantic errors and generate an AST.")
        s.append(sep)
        s.append("       -c, --full-compile      Full Compilation (default). Run the full compilation process.")
        s.append(sep)
        s.append("       -t, --target            Target. Select target architecture (default arm32, options: x86-64-intel or x86-64).")
        s.append(sep)
        s.append("       -o, --optimise          Optimise. Run ARM Peephole optimisations over the generated assembly code.")
        s.append(sep)
        s.append("       -a, --print-assembly    View Assembly. Display ARM assembly code generated by the code generator.")
        s.append(sep)
        s.append("       -x, --execute           Execute. Assemble and Emulate the generated ARM code and display its output.")
        s.append(sep)
        s.append("       -d, --directory         Give directory of wacc files.")
        s.append(sep)
        s.append("       -h, --help              Show this message.")
        s.append(sep)
        s.append(sep)
        s.append(sep)
        s.append("   target.wacc: path to wacc program file to compile (or target directory if --directory option set)")
        return s.toString
    }
}